# 🚩 Greedy Algorithm 학습 기록

**그리디 알고리즘**, 현재 상황에서 가장 좋아 보이는 것만을 선택하는 알고리즘

---

## 📂 문제 및 핵심 요약

| 파일명 | 문제명 | 핵심 배울 점 |
| --- | --- | --- |
| **3_1.py** | 거스름돈 | 리스트를 활용한 확장성 확보, `//`와 `%` 연산의 조합 |
| **3_2.py** | 큰 수의 법칙 | 반복되는 수열의 패턴을 파악하여 수학적 수식으로 변환 |
| **3_3.py** | 숫자 카드 게임 | 불필요한 리스트 생성을 피하고 변수 하나로 최댓값 유지 |
| **3_4.py** | 1이 될 때까지 | 1씩 빼는 대신 나머지를 활용해 목표값까지 한 번에 이동 |

---

## 주요 학습 포인트

### 1. 시간 복잡도 최적화: "노가다에서 점프로"

단순히 `while` 문 안에서 `n -= 1`을 반복하는 것은 데이터가 커질 때 성능 저하의 주범이 된다.

* **기존 방식:** 나누어떨어질 때까지 1씩 차감 ( 위험)
* **개선 방식:** 나머지를 계산하여 다음에 나눌 수 있는 지점으로 한 번에 도달 ()

### 2. 공간 복잡도 효율성: "버릴 데이터는 기억하지 말자"

모든 중간 결과값을 리스트에 담아두는 습관을 버리자.

* **기존 방식:** 각 행의 최솟값을 리스트에 다 저장한 뒤 마지막에 `max()` 호출
* **개선 방식:** 입력받는 즉시 현재의 최솟값을 기존 결과값과 비교하여 갱신함으로써 메모리 사용량을 O(1)로 제한

### 3. 코드의 확장성: "조건문 대신 반복문"

유사한 조건이 반복될 때는 리스트와 반복문을 조합하여 코드 길이를 줄이고 유연성을 높여야 한다.

* **적용:** 동전의 종류를 리스트 `coins`에 담아 처리함으로써, 화폐 종류가 추가되어도 로직 수정 없이 리스트만 업데이트하면 됨

---

## 💬 총평

작동하는 코드를 짜는 것은 시작일 뿐: 데이터의 범위가 커질 것을 대비해 **수학적으로 점프할 구간**을 찾고, **메모리를 아끼는 구조**를 설계하는 것이 중요한 접근임을 체감했다.